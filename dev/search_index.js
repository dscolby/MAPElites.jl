var documenterSearchIndex = {"docs":
[{"location":"guide/#Installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"pkg> add MAPElites","category":"page"},{"location":"guide/#Usage","page":"Guide","title":"Usage","text":"","category":"section"},{"location":"guide/#Standard-Workflow","page":"Guide","title":"Standard Workflow","text":"","category":"section"},{"location":"guide/#Mixing-and-Matching-Components","page":"Guide","title":"Mixing and Matching Components","text":"","category":"section"},{"location":"guide/#Using-with-Optimizers.jl","page":"Guide","title":"Using with Optimizers.jl","text":"","category":"section"},{"location":"guide/#Algorithms","page":"Guide","title":"Algorithms","text":"","category":"section"},{"location":"guide/#MAP-Elites","page":"Guide","title":"MAP-Elites","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"MAP Elites initializes a discretized behavior grid with random solutions, then uses genetic  operators to improve the solutions in each grid cell. This results in an archive of diverse,  high-performing solutions.[1]","category":"page"},{"location":"guide/#CVT-MAP-Elites","page":"Guide","title":"CVT-MAP-Elites","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Central Voronoi tesselation MAP-Elites (CVT-MAP-Elites) replaces fixed grid cells with a fixed  number of Voronoi tesselations to scale MAP-Elites to higher dimensional behavior spaces.[2]","category":"page"},{"location":"guide/#AURORA","page":"Guide","title":"AURORA","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"AUtonomous RObots that Realize their Abilities (AURORA) extends MAP-Elites to high-dimensional  or complicated behavior spaces by using unsupervised learning methods to project behavioral  descriptors into a lower dimensional latent space and store them in an adaptively sized archive.[3]  The implementation in MAPElites.jl uses principal component analysis as the dimensionality reduction  technique, which tended to perform better than an autoencoder in experiments in the original paper.","category":"page"},{"location":"guide/#SAIL","page":"Guide","title":"SAIL","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Surrogate assisted illumination (SAIL) combines MAP-Elites with a Gaussian process regression (GP)  to reduce sample complexity. After initially filling a behavioral archive, SAIL trains a on the archive to predict the objective function. Then, SAIL uses another archive, the acquisition archive,  to run UCB on the initial solutions, replacing the objective function with an upper confidence bound  estimate from the GP. Then, k solutions are sampled from the acquisition archive and evaluated on the objectie function. If they perform better than the solution in corresponding cell of the behavioral  archive, then they replace that behavior. The process then repeats for a fixed number of iterations.[4]","category":"page"},{"location":"guide/#CMA-MAP-Elites","page":"Guide","title":"CMA-MAP-Elites","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Covariance Matrix Adaptation MAP-Elites (CMA MAP-Elites) improves the sample efficiency of the  original MAP-Elites algorithm by replacing the crossover and mutation operators with covariance  matrix adaptation.[5]","category":"page"},{"location":"guide/#References","page":"Guide","title":"References","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"[1]: Mouret, Jean-Baptiste, and Jeff Clune. \"Illuminating search spaces by mapping elites.\" arXiv preprint arXiv:1504.04909 (2015).","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"[2]: Vassiliades, Vassilis, Konstantinos Chatzilygeroudis, and Jean-Baptiste Mouret. \"Using centroidal voronoi tessellations to scale up the multidimensional archive of phenotypic elites algorithm.\" IEEE Transactions on Evolutionary Computation 22, no. 4 (2017): 623-630.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"[3]: Cully, Antoine. \"Autonomous skill discovery with quality-diversity and unsupervised descriptors.\" In Proceedings of the Genetic and Evolutionary Computation Conference, pp. 81-89. 2019.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"[4]: Gaier, Adam, Alexander Asteroth, and Jean-Baptiste Mouret. \"Data-efficient exploration, optimization, and modeling of diverse designs through surrogate-assisted illumination.\" In Proceedings of the Genetic and Evolutionary Computation Conference, pp. 99-106. 2017.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"[5]: Fontaine, Matthew C., Julian Togelius, Stefanos Nikolaidis, and Amy K. Hoover. \"Covariance matrix adaptation for the rapid illumination of behavior space.\" In Proceedings of the 2020 genetic and evolutionary computation conference, pp. 94-102. 2020.","category":"page"},{"location":"CHANGELOG/#Changelog","page":"Release Notes","title":"Changelog","text":"","category":"section"},{"location":"CHANGELOG/#[Unreleased]","page":"Release Notes","title":"[Unreleased]","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<div style=\"text-align: center; padding: 1rem;\">\n            <a class=\"github-button\"\n               href=\"https://github.com/dscolby/MAPElites.jl\"\n               data-icon=\"octicon-star\"\n               data-size=\"large\"\n               data-show-count=\"true\"\n               aria-label=\"Star dscolby/MAPElites.jl on GitHub\">\n               Star\n            </a>\n            <script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n        </div>","category":"page"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Most optimization algorithms search for a single best solution, but this can be suboptimal for various reasons. First, many optimizers get stuck in a local min/maximum searching for a single best solution. Second, a lot of optimizers are unable to balance exploration and exploitation, which can lead them to overlook promising solutions or even get stuck in local optima. Third, almost all  optimization algorithms are not ammenable to understanding the relationship between features and  performance â€” they are bascially just black boxes. And finally, and arguably the biggest motivation,  is that traditional optimization seeks a single best solution for a given situation. However, what  works well in one situation might not be the best solution for another. Quality-diversity algorithms address these shortcomings by searching for a diverse set of high performing solutions, rather  than a single solution. One of the most successful and widely used quality-diversity algorithms  is Multi-dimensional Archive of Phenotypic Elites (MAP-Elites), which can be categorized as an  evolutionary algorithm. MAP-Elites uses genetic operators to evolve high quality candidate solutions  at each point within a discretized behavior (feature) space, which the user can choose.[1]","category":"page"},{"location":"#Package","page":"Home","title":"Package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modularity: MAPElites.jl includes various types of archives, behavior descriptor functions,    fitness functions, and variation operators that you can mix and match however you see fit.   Furthermore, you can easily extend MAPElites.jl's functionality by implementing your own    components and mixing and matching them with existing components.\nSimplicity at its core: While MAPElites.jl has many modular components for you to mix    and matched, you really only need one struct to use them. Additionally, several MAP-Elites   variants are implemented that you can run with on function call.\nLibrary-agnostic: Unlike some Python implementations of quality-diversity algorithms, MAPElites.jl   doesn't require you to use any specific library for arrays or tensors. You are free to use base    Julia, CUDA arrays from CUDA.jl, or any other library. As long as your fitness function can    evaluate your candidate solutions, you can use whatever data structure you want, be it arrays,    strings, images, or anything else.\nWorks with Optimization.jl: The implementations in MAPElites.jl can also be called from within   Optimization.jl (coming soon).","category":"page"},{"location":"#Alternatives","page":"Home","title":"Alternatives","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are a few alternatives to MAPElites.jl for quality-diversity algorithms written in Python.","category":"page"},{"location":"","page":"Home","title":"Home","text":"QDax: A Jax-based implementation of several quality-diversity algorithms mostly designed around    reinforcement learning and robotics.\nPyRibs: A barebones Python implementation that uses an ask-tell interface that also focuses on    reinforcement learning.\nqdpy: A generic minimal implementation of quality-diversity algroithms in Python.\nCVT-MAP-Elites: A simple Python implementation of CVT-MAP-Elites.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Mouret, Jean-Baptiste, and Jeff Clune. \"Illuminating search spaces by mapping elites.\" arXiv preprint arXiv:1504.04909 (2015).","category":"page"},{"location":"developers/#MAPElites.jl","page":"Developers","title":"MAPElites.jl","text":"","category":"section"},{"location":"developers/#MAPElites.jl-APIs","page":"Developers","title":"MAPElites.jl APIs","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"MAPElites.jl maximizes modularity and extensibility by using a strategy design pattern. A full MAPElites container takes a variation strategy for mutating candidate solutions, a fitness  strategy for evaluating candidate fitness, and a behavior descriptor strategy for calculating behavior descriptors for candidate solutions. Each solution, along with its behavior descriptor,  and fitness are stored in an archive, which is a subtype of an AbstractArchive. These components are explained more below.","category":"page"},{"location":"developers/#AbstractArchive","page":"Developers","title":"AbstractArchive","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"The MAPElites struct expects an archive that implements the AbstractArchive API to store solutions.  All subtypes of AbstractArchive must implement the findniche and Base.setindex! functions.  The findniche method must take as inputs a concrete archive and a behavior descriptor vector and return an index in the archive that corresponds to the given behavior descriptor. The setindex!  method must set or update the given index in the archive with the given solution, behavior descriptor,  and fitness. Optionally, a subtype of AbstractArchive may also include selectrandom, selectbestelite,  and selectworstelite methods that return a tuple containing a solution, behavior descriptor, and  fitness that is either random, the best solution, or the worst solution. In any case, all concrete  archives must have at least one method to retrieve an elite, and selectrandom, selectbestelite,  and selectworstelite are suggested methods.","category":"page"},{"location":"developers/#VariationStrategy","page":"Developers","title":"VariationStrategy","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"Running MAP-Elites or a variant requires some way to create child solutions by mutating or changing  parent solutions. In MAPElites.jl, this is a variation strategy that is a subtype of the  VariationStrategy abstract type. A concrete variation strategy can contain arbitrary fields, e.g.  to keep track of the iteration or parameters for a normal distribution. Additionally, a concrete  variation strategy must have an associated functor that accepts a candidate solution and returns a new candidate solution.","category":"page"},{"location":"developers/#FitnessStrategy","page":"Developers","title":"FitnessStrategy","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"Running MAP-Elites also requires some way to evaluate the fitness of candidate solutions, which is  accomplished by using a fitness strategy. Fitness strategies must be subtypes of the FitnessStrategy  abstract type. Concrete fitness strategies may have any arbitraryi fields. For example, a fitness  strategy may include a surrogate model such as a Gaussian process regression to avoid computing  an expensive fitness function at every iteration. Like variation strategies, fitness strategies must implement a functor that accepts a candidate solution as an argument and returns a concrete subbtype  of Real.","category":"page"},{"location":"developers/#BehaviorDescriptorStrategy","page":"Developers","title":"BehaviorDescriptorStrategy","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"A key ingredient of MAP-Elites and its variants is a behavior descriptor. In MAPElites.jl, this  takes the form of behavior descriptor strategies. All concrete behavior descriptor strategies must be subtypes of the BehaviorDescriptorStrategy abstract type and implement a functor that takes in  a raw behavior descriptor and outputs a behavior descriptor vector. Like other strategies, subtypes  can store arbitrary information and can be as simple as returning the behavior descriptor that is  passed as an argument or as complicated as using a dimensionality reduction technique like a VAE.","category":"page"},{"location":"developers/#Modules","page":"Developers","title":"Modules","text":"","category":"section"},{"location":"developers/#MAPElites","page":"Developers","title":"MAPElites","text":"MAPElites contains implementations of the MAP-Elites, CVT-MAP-Elites, AURORA, SAIL, and  CMA-MAP-Elites as well as archives, fitness strategies and functors, behavior descriptor  strategies and functors, variation operators, and selection operators that can be mixed and  matched.\n\nFor more information on MAP-Elites, see:     Mouret, Jean-Baptiste, and Jeff Clune. \"Illuminating search spaces by mapping elites.\"      arXiv preprint arXiv:1504.04909 (2015).\n\n\n\n\n\n","category":"module"},{"location":"developers/#Abstract-Types","page":"Developers","title":"Abstract Types","text":"","category":"section"},{"location":"developers/#MAPElites.AbstractArchive","page":"Developers","title":"MAPElites.AbstractArchive","text":"An abstract type that all archives must be subtypes of. All subtypes must implement the      findniche, Base.setindex!, selectrandom, selectbestelite, and      selectworstelite methods.\n\n\n\n\n\n","category":"type"},{"location":"developers/#MAPElites.VariationStrategy","page":"Developers","title":"MAPElites.VariationStrategy","text":"An abstract type that all variation strategies must be subtypes of. Concrete variation      strategies can store any state information such as iterations or hyperparameters and      must implement the vary method.\n\n\n\n\n\n","category":"type"},{"location":"developers/#MAPElites.FitnessStrategy","page":"Developers","title":"MAPElites.FitnessStrategy","text":"An abstract type that all fitness strategies must be subtypes of. Concrete fitness      strategies can store state information such as iterations, hyperparemeters, or other      data structures. For example, a fitness strategy could store a surrogate model to avoid      evaluating a costly fitness function at every iteration. All subtypes must implement a      fitness method.\n\n\n\n\n\n","category":"type"},{"location":"developers/#MAPElites.BehaviorDescriptorStrategy","page":"Developers","title":"MAPElites.BehaviorDescriptorStrategy","text":"An abstract type that all concrete behavior descriptor strategies must be subtypes of.     In its simplest form, a behavior descriptor strategy can just return the original      behavior descriptor vector it is passed. However, a behavioral descriptor strategy could      also store state information or dimensionality reduction methods, for example. All      subtypes must implement a describe_behavior method.\n\n\n\n\n\n","category":"type"},{"location":"developers/#Structs","page":"Developers","title":"Structs","text":"","category":"section"},{"location":"developers/#MAPElites.Algorithm","page":"Developers","title":"MAPElites.Algorithm","text":"Algorithm(arch, sel, var_strat, fit_strat, bd_strat, init, [, k, iterations])\n\nInitialize an algorithm type to run MAP-Elites or one of its variants.\n\nArguments\n\narch::AbstractArchive: A subtype of AbstractArchive for storing solutions.\nsel::Function: A function to select a solution grom the archive.\nvar_strat::VariationStrategy: A subtype of VariationStrategy to vary or mutate solutions.\nfit_strat::FitnessStrategy: A subtype of FitnessStrategy to evaluate solutions.\nbd_strat::BehaviorDescriptorStrategy: A subtype of BehaviorDescriptorStrategy to   generate behavior descriptors.\ninit::Function: A function that accepts a random number generator and returns a solution   for initializing the archive.\nk::Int=1000: The number of candidates to generate for initialization.\niterations::Int=10000: The number of iterations to run the algorithm for.\n\nExamples\n\njulia> dims, lb, ub = (3, 4), (0.0, -1.0), (1.0, 2.0)\njulia> g = GridArchive(dims, lb, ub)\njulia> sel = select_random()\njulia> var_strat = CMA()\njulia> init = my_initializer()\njulia alg = Algorithm(g, sel, var_strat, init)\n\n\n\n\n\n","category":"type"},{"location":"developers/#MAPElites.GridArchive","page":"Developers","title":"MAPElites.GridArchive","text":"A struct to store solutions and their fitnesses in a discretized behavior grid.\n\n\n\n\n\n","category":"type"},{"location":"developers/#Functions","page":"Developers","title":"Functions","text":"","category":"section"},{"location":"developers/#MAPElites.find_niche","page":"Developers","title":"MAPElites.find_niche","text":"Find the index of the archive for the corresponding behavior descriptor.\n\nThis method must be implemented for all subtypes of AbstractArchive. When implementing a new      find_niche method on a subtype of AbstractArchive, the method must return a tuple      corresponding to the index in the archive.\n\n\n\n\n\n","category":"function"},{"location":"developers/#Base.getindex","page":"Developers","title":"Base.getindex","text":"Base.getindex(g, key...)\n\nGet a tuple of the solution, behavior_descriptor, and fitness of the corresponding index.\n\nArguments\n\ng::GridArchive: A GridArchive to retrive the data from.\nkey...::Tuple: A tuple corresponding to the index to retrieve data from.\n\nExamples\n\njulia> dims, lb, ub = (5,), (0.0,), (10.0,)\njulia> g = GridArchive(dims, lb, ub)\njulia> idx = 2, 1\njulia> g[idx...]\n(nothing, nothing, nothing)\n\n\n\n\n\n","category":"function"},{"location":"developers/#Base.setindex!","page":"Developers","title":"Base.setindex!","text":"Base.setindex!(g, value, key...)\n\nSet the solution, behavior_descriptor, and fitness of the corresponding index in a      GridArchive.\n\nArguments\n\ng::GridArchive: A GridArchive to retrive the data from.\nvalue::Tuple{Any, AbstractVector{<:Real}, <Real}: The solution, behavior descriptor, and    fitness function to assign to the key.\nkey...::Tuple: A tuple corresponding to the index to retrieve data from.\n\nExamples\n\njulia> dims, lb, ub = (5,), (0.0,), (10.0,)\njulia> g = GridArchive(dims, lb, ub)\njulia> idx = 2, 1\njulia> g[idx...] = (90, [1.0, 2.0], 3.0)\njulia> g[idx...]\n(90, [1.0, 2.0], 3.0)\n\n\n\n\n\n","category":"function"},{"location":"developers/#MAPElites.select_random","page":"Developers","title":"MAPElites.select_random","text":"Get a random solution and its corresponding behavior descriptor and fitness from an archive.\n\nThis method may optionally be extened to new subtypes of AbstractArchive. When implementing      a new select_random method on a subtype of AbstractArchive, the method must return a      tuple of solution, behavior descriptor, fitness.\n\n\n\n\n\n","category":"function"},{"location":"developers/#MAPElites.select_best_elite","page":"Developers","title":"MAPElites.select_best_elite","text":"Get the best performing solution and its corresponding behavior descriptor and fitness from  an archive.\n\nThis method may optionally be extended to new subtypes of AbstractArchive. When implementing      a new selectbestelite method on a subtype of AbstractArchive, the method must      return a tuple of soltuion, behavior descriptor, fitness.\n\n\n\n\n\n","category":"function"},{"location":"developers/#MAPElites.select_worst_elite","page":"Developers","title":"MAPElites.select_worst_elite","text":"Get the worst performing solution and its corresponding behavior descriptor and fitness from  an archive.\n\nThis method may optionally be extended to subtypes of AbstractArchive. When implementing a      new selectworstelite method on a subtype of AbstractArchive, the method must return      a tuple of soltuion, behavior descriptor, fitness.\n\n\n\n\n\n","category":"function"},{"location":"developers/#Contributing","page":"Developers","title":"Contributing","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"All contributions are welcome. To ensure contributions align with the existing code base and  are not duplicated, please follow the guidelines below.","category":"page"},{"location":"developers/#Reporting-a-Bug","page":"Developers","title":"Reporting a Bug","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"To report a bug, open an issue on GitHub page.  Please include all relevant information, such as what methods were called, the operating system used,  the verion/s of MAPElites.jl used, the verion/s of Julia used, any tracebacks or error codes, and  any other information that would be helpful for debugging. Also be sure to use the bug label.","category":"page"},{"location":"developers/#Requesting-New-Features","page":"Developers","title":"Requesting New Features","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"Before requesting a new feature, please check the issues page on GitHub  to make sure someone else did not already request the same feature. If this is not the case, then  please open an issue that explains what function or method you would like to be added and how you  believe it should behave. Also be sure to use the enhancement tag.","category":"page"},{"location":"developers/#Contributing-Code","page":"Developers","title":"Contributing Code","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"Before submitting a pull request, please  open an issue explaining what the proposed code is and why you want to add it, if there is  not already an issue that addresses your changes and you are not fixing something very  minor. When submitting a pull request, please reference the relevant issue/s and ensure your  code follows the guidelines below. Please also see above for an overview of how this package  and its components are designed.","category":"page"},{"location":"developers/","page":"Developers","title":"Developers","text":"Before being merged, all pull requests should be well tested and all tests must be passing.\nAll abstract types, structs, functions, methods, macros, and constants have docstrings    that follow the same format as the other docstrings. These functions should also be    included in the relevant section above.\nThere are no repeated code blocks. If there are repeated codeblocks, then they should be    consolidated into a separate function.\nInternal methods can contain types and be parametric but public methods should be as    general as possible.\nMinimize use of new constants and macros. If they must be included, the reason for their    inclusion should be obvious or included in the docstring.\nIn most cases, avoid using global variables and constants.\nCode should take advantage of Julia's built in macros for performance. Use @inbounds,    @view, @fastmath, and @simd when possible.\nWhen appending to an array in a loop, preallocate the array and update its values by    index.\nAvoid long functions and decompose them into smaller functions or methods. A general    rule is that function definitions should fit on your screen.\nUse self-explanatory names for variables, methods, structs, constants, and macros.\nMake generous use of whitespace.\nAll functions should include docstrings.","category":"page"},{"location":"developers/","page":"Developers","title":"Developers","text":"note: Note\nMAPElites.jl follows the Blue style guide and all code is automatically formatted to  conform with this standard upon being pushed to GitHub.","category":"page"},{"location":"developers/#Updating-or-Fixing-Documentation","page":"Developers","title":"Updating or Fixing Documentation","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"To propose a change to the documentation please submit an issue  or pull request.","category":"page"}]
}
